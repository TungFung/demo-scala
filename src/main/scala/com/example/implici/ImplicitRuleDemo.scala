package com.example.implici

/**
 * 隐式规则
 * 1.标记规则：必须要有implicit关键字，可以用在函数，类，变量，对象
 * 2.作用域规则：被插入的隐式转换必须是当前作用域的单个标识符，或者是跟隐式转换的源类型或目标类型有关联。
 *    当前作用域包括显式import进来的，scala默认import进来的
 *    需要隐式转换的源类型中的伴生对象，或目标类型中的伴生对象
 *    单个标识符意思是import进来要到方法级别，调用时就只用单个标识符就能调用像convert()，而不能是xxx.convert()
 *    一般做法：提供一个Preamble对象里面放隐式转换，这样只要import Preamble._ 就行
 * 3.每次一个规则：每次只能有一个隐式定义被插入，不会隐式转换后，又转一次。
 * 4.显式优先原则：只要能正常编译通过就不会尝试隐式定义
 *
 * 应用隐式的地方
 * 1.变量接收赋值时类型不匹配隐式转换
 * 2.对象调用方法时隐式转换成其他类型实例，调用自己没有的方法
 * 3.隐式参数列表，调用时没传最后一个参数列表的参数，编译器隐式的传入了
 *
 * 当找到多个隐式定义时，比较哪个定义更具体应用哪个，如果比不出哪个更具体则报错
 * 1.前者的入参类型是后者入参类型的子类型
 * 2.两者都是方法，而前者所在的类扩展自后者所在的类
 *
 * 调试隐式转换
 * 1.通过scala提供的 def implicitly[T](implicit t: T) = t 函数来查找检查得到的隐式对象是什么
 * 2.通过 -Xprint:typer 编译器选项运行scalac，会显示隐式转换后代码是怎样的
 */
class ImplicitRuleDemo {

}
